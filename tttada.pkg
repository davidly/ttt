--    Janus Ada v1.5 of an app that proves you can't win at tic-tac-toe if the opponent is competent.
--    Build like this:
--        ntvcm janus %1 /L
--        ntvcm jlink %1

With Util, Strlib;

Package Body tttada Is

Use Util;
Use Strlib;

ScoreWin : Constant := 6;
ScoreTie : Constant := 5;
ScoreLose : Constant :=  4;
ScoreMax : Constant := 9;
ScoreMin : Constant := 2;
DefaultIterations : Constant := 1;

PieceX : Constant := 1;
PieceO : Constant := 2;
PieceBlank : Constant := 0;

moves : Integer;
board : Array(0..8) Of Integer;

function LookForWinner return integer is
p : integer;
begin
    p := board(0);
    if ( PieceBlank /= p ) then
        if ( ( p = board(1) ) and ( p = board(2) ) ) then return p; end if;
        if ( ( p = board(3) ) and ( p = board(6) ) ) then return p; end if;
    end if;

    p := board(3);
    if ( ( PieceBlank /= p ) and ( p = board(4) ) and ( p = board(5) ) ) then return p; end if;

    p := board(6);
    if ( ( PieceBlank /= p ) and ( p = board(7) ) and ( p = board(8) ) ) then return p; end if;

    p := board(1);
    if ( PieceBlank /= p and p = board(4) and p = board(7) ) then return p; end if;

    p := board(2);
    if ( PieceBlank /= p and p = board(5) and p = board(8) ) then return p; end if;

    p := board(4);
    if ( PieceBlank /= p ) then
        if ( ( p = board(0) ) and ( p = board(8) ) ) then return p; end if;

        if ( ( p = board(2) ) and ( p = board(6) ) ) then return p; end if;
    end if;

    return PieceBlank;
end LookForWinner;

function pos0func( x : in integer )  return integer is
begin
    if ( ( x = board(1) and x = board(2) ) or
         ( x = board(3) and x = board(6) ) or
         ( x = board(4) and x = board(8) ) ) then return x; end if;
    return PieceBlank;
end pos0func;

function pos1func( x : in integer )  return integer is
begin
    if ( ( x = board(0) and x = board(2) ) or
         ( x = board(4) and x = board(7) ) ) then return x; end if;
    return PieceBlank;
end pos1func;

function pos2func( x : in integer )  return integer is
begin
    if ( ( x = board(0) and x = board(1) ) or
         ( x = board(5) and x = board(8) ) or
         ( x = board(4) and x = board(6) ) ) then return x; end if;
    return PieceBlank;
end pos2func;

function pos3func( x : in integer )  return integer is
begin
    if ( ( x = board(4) and x = board(5) ) or
         ( x = board(0) and x = board(6) ) ) then return x; end if;
    return PieceBlank;
end pos3func;

function pos4func( x : in integer )  return integer is
begin
    if ( ( x = board(0) and x = board(8) ) or
         ( x = board(2) and x = board(6) ) or
         ( x = board(1) and x = board(7) ) or
         ( x = board(3) and x = board(5) ) ) then return x; end if;
    return PieceBlank;
end pos4func;

function pos5func( x : in integer )  return integer is
begin
    if ( ( x = board(3) and x = board(4) ) or
         ( x = board(2) and x = board(8) ) ) then return x; end if;
    return PieceBlank;
end pos5func;

function pos6func( x : in integer )  return integer is
begin
    if ( ( x = board(7) and x = board(8) ) or
         ( x = board(0) and x = board(3) ) or
         ( x = board(4) and x = board(2) ) ) then return x; end if;
    return PieceBlank;
end pos6func;

function pos7func( x : in integer ) return integer is
begin
    if ( ( x = board(6) and x = board(8) ) or
         ( x = board(1) and x = board(4) ) ) then return x; end if;
    return PieceBlank;
end pos7func;

function pos8func( x : in integer ) return integer is
begin
    if ( ( x = board(6) and x = board(7) ) or
         ( x = board(2) and x = board(5) ) or
         ( x = board(0) and x = board(4) ) ) then return x; end if;
    return PieceBlank;
end pos8func;

function LookForWin( move : integer ) return integer is
x : integer;
begin
    -- Note: the function type below doesn't compile and I can't find a manual for Janus Ada
    --       type scoreproc is access function return integer;
    -- As a (much slower) fallback, use a case statement

    x := board( move );

    case move is
        when 0 => return pos0func(x);
        when 1 => return pos1func(x);
        when 2 => return pos2func(x);
        when 3 => return pos3func(x);
        when 4 => return pos4func(x);
        when 5 => return pos5func(x);
        when 6 => return pos6func(x);
        when 7 => return pos7func(x);
        when 8 => return pos8func(x);
    end case;

    return PieceBlank;
end LookForWin;

function MinMax( alphaarg : in integer; betaarg : in integer; depth : in integer; move : in integer ) return integer is
alpha, beta, p, value, score, pieceMove : integer;
begin
    alpha := alphaarg;
    beta := betaarg;
    moves := moves + 1;
    if ( depth >= 4 ) then
        --p := LookForWinner();
        p := LookForWin( move ); -- about 10% fewer cycles than LookForWinner
        if ( PieceBlank /= p ) then
            if ( PieceX = p ) then return ScoreWin; end if;
            return ScoreLose;
        end if;
        if ( 8 = depth ) then return ScoreTie; end if;
    end if;

    if ( ( depth mod 2 ) = 1 ) then
        value := ScoreMin;
        pieceMove := PieceX;
    else
        value := ScoreMax;
        pieceMove := PieceO;
    end if;

    for p in 0..8 loop
        if ( PieceBlank = board( p ) ) then
            board( p ) := pieceMove;
            score := MinMax( alpha, beta, depth + 1, p );
            board( p ) := pieceBlank;

            if ( ( depth mod 2 ) = 1 ) then
                if ( score = ScoreWin ) then return ScoreWin; end if;
                if ( score > value ) then
                    value := score;
                    if ( value >= beta ) then return value; end if;
                    if ( value > alpha ) then alpha := value; end if;
                end if;
            else
                if ( score = ScoreLose ) then return ScoreLose; end if;
                if ( score < value ) then
                    value := score;
                    if ( value <= alpha ) then return value; end if;
                    if ( value < beta ) then beta := value; end if;
                end if;
            end if;
        end if;
    end loop;

    return value;
end MinMax;

procedure FindSolution( move : in integer ) is
score : integer;
begin
    board( move ) := PieceX;
    score := MinMax( ScoreMin, ScoreMax, 0, move );
    board( move ) := PieceBlank;
end FindSolution;

i, iterations : integer;
cmd : string;

begin
    cmd := Command_Line();
    iterations := str_to_int( cmd );
    if ( 0 = iterations ) then iterations := DefaultIterations; end if;

    for i in 0..8 loop
        board( i ) := PieceBlank;
    end loop;

    Put("starting..."); New_line;

    for i in 1..iterations loop
        moves := 0;
        FindSolution( 0 );
        FindSolution( 1 );
        FindSolution( 4 );
    end loop;

    Put( "Moves:      " ); Put( moves ); New_line;
    Put( "Iterations: " ); Put( iterations ); New_line;
end tttada;
